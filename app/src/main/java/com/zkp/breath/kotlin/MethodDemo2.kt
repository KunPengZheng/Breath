package com.zkp.breath.kotlin

/**
 * 函数类型：是一类类型，不是一种类型，因参数类型，返回值类型不同而不同。
 *
 * 高阶函数：参数或者返回值为函数类型的函数。
 *
 * 函数引用（Function Reference）：函数作为参数的本质是因为函数在kotlin里可作为对象存在，因为只有对象才能被作为
 * 参数传递，赋值也是一样道理，只有对象才能被赋值给变量。kotlin使用使用“::函数名”则创建一个和函数相同功能的对象，
 * 切记它不是一个函数，而是一个函数类型的对象（也可以说是一个指向对象的引用），但并不是指向函数本身，而是指向一个
 * 我们在代码里看不见的对象，这个对象复制了原函数的功能，但它并不是原函数。实际上你对一个函数类型的对象加括号、
 * 加参数，它真正调用的是这个对象的 invoke() 函数（语法糖），因为只有函数类型的对象有这个自带的 invoke() 可以用。
 *
 * 匿名函数（无名字的函数）：要传一个函数类型的参数，或者把一个函数类型的对象赋值给变量，除了用双冒号来拿现成的函数使用，
 * 你还可以直接把这个函数挪过来写，但这两种方式只能在函数中声明。如下例子：
 *
 */


fun a(funParam: (Int) -> String): String {
    return funParam(1)
}

fun b(int: Int) = int.toString()


fun main() {
    b(1)    // 调用函数
    val kFunction1 = ::b    // 函数引用，指向函数类型对象的引用
    val kFunction2 = kFunction1 // 赋值操作，因为右边已经是一个函数类型对象，所以不用再加“::”
    kFunction1(1)   // 使用函数引用实现和b函数的等价操作，实际上调用的是这个对象的invoke()函数(一种语法糖)
    // 使用函数引用实现和b函数的等价操作，实际上调用的是这个对象的invoke()函数(一种语法糖)。
    // 切记这种方式函数引用需要加括号，因为对象是不能加个括号来调用的。如：对象(函数参数)
    (::b)(1)
    a(::b)  // ::b为函数引用


    // 匿名函数
    a(fun(param: Int): String {
        return param.toString()
    })

    // 右边能推导出类型，左边的类型声明可省略
    val d = fun(param: Int): String {
        return param.toString()
    }

}
