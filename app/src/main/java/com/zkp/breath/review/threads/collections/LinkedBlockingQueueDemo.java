package com.zkp.breath.review.threads.collections;

/**
 * 基于单链表实现的阻塞队列，是一种近似有界阻塞队列（构造的可以不指定容量，则容量默认Integer.MAX_VALUE），
 * 它维护了两把锁（takeLock和putLock）,takeLock用于控制出队的并发，putLock用于入队的并发。这也就意味着，
 * 同一时刻，只能只有一个线程能执行入队/出队操作，其余入队/出队线程会被阻塞；但是，入队和出队之间可以并发执行，
 * 即同一时刻，可以同时有一个线程进行入队，另一个线程进行出队，这样就可以提升吞吐量。
 * <p>
 * 插入元素时，首先需要获得“入队锁”，如果队列满了，则当前线程需要在notFull条件队列等待；否则，将新元素链接到队列尾部。
 * 1.每入队一个元素后，如果队列还没满，则需要唤醒其它可能正在等待的“入队线程”
 * 2.每入队一个元素，都要判断下队列是否空了（用在执行1之前获取到的队列长度），如果空了，说明可能存在正在等待的“出队线程”，需要唤醒它。
 * <p>
 * 删除元素的逻辑和插入元素类似。删除元素时，首先需要获得“出队锁”，如果队列为空，则当前线程需要在notEmpty条件队列等待；否则，从队首出队一个元素：
 * 1.每出队一个元素后，如果队列非空，则需要唤醒其它可能正在等待的“出队线程”
 * 2.每出队一个元素，都要判断下队列是否满（用在执行1之前获取到的队列长度），如果是满的，说明可能存在正在等待的“入队线程”，需要唤醒它：
 */
public class LinkedBlockingQueueDemo {

    public static void main(String[] args) {

    }

}
